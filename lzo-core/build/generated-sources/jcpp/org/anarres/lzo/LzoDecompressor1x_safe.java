package org.anarres.lzo;

import java.util.Arrays;

public class LzoDecompressor1x_safe extends AbstractLzoDecompressor {

    public LzoDecompressor1x_safe() {
        super(LzoAlgorithm.LZO1X, LzoConstraint.SAFETY);
    }



































// In Java, all of these are array indices.












// for lzo1y.h and lzo1z.h


// Unfortunately clobbered by config1x.h etc
// #define LZO_DETERMINISTIC (1)




// NOT a macro because liblzo2 assumes that if UA_GET32 is a macro,
// then it is faster than byte-array accesses, which it is not -
// or, if it is, hotspot will deal with it.
private static int UA_GET32(byte[] in, int in_ptr) {
	return (((in[in_ptr]) & 0xff) << 24) | (((in[in_ptr + 1]) & 0xff) << 16) | (((in[in_ptr + 2]) & 0xff) << 8) | ((in[in_ptr + 3]) & 0xff);
}


/* config1x.h -- configuration for the LZO1X algorithm

   This file is part of the LZO real-time data compression library.

   Copyright (C) 2011 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */


/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the library and is subject
   to change.
 */










/* lzo_conf.h -- main internal configuration file for the the LZO library

   This file is part of the LZO real-time data compression library.

   Copyright (C) 2011 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */


/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the library and is subject
   to change.
 */














































/***********************************************************************
// pragmas
************************************************************************/









   

   












/***********************************************************************
//
************************************************************************/
















/* ACC --- Automatic Compiler Configuration

   This file is part of the LZO real-time data compression library.

   Copyright (C) 2011 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































   


   


   


   




   













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































   
   

























   
   



   
   



























































































   
   




   
   



















































   
   



















































































































   



   



   


















    
    
    
    






    
    
























    
    
    
    






    
    




















































   
   

























   
   



   
   



























































































   
   




   
   



















































   
   


















































































































   



   



   


















    
    
    
    






    
    
























    
    
    
    






    
    






























































































































































































































































































































   
   












































































































































































    

    
    
    

    

    
    
    
    
    

    
    
    
    
    
    
    
    

    
    


































   































    
    
    
    
    


    

    

    






































    
    
    
    
    

    


    




    

    
    

    

















    
    
    
    

    


    



    
        


        


        


    

    


    


    


























    
    
    
    


    
    
    
    
    
    
    
    
    
    
    




                                      

                                
                                
                                

    








    










    









    
    









    
    



































































































































































    


    


    


    
    
    

    
    

    


    
    


    


    


    
    


    

    
    
    
    
    


    
    

    
    

    
    
    
    
    


    


    



    



    
    
    

    
    


    
    


    
    
    

    

    


    


    

    
    
    

    

    
    
    

    

    
    
    
    

    

    
    
    

    

    
    
    
    

    

    
    
    

    

    



    

    

    
    


    
    


    
    

    
    




    

    


    

    

    
    
    
    
    
    


    

    

    



    
    
    
    
    
    
    
    
    
    

    



    

    
    
    
    
    
    
    
    
    

    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    


    




    

    
    
    
    
    
    
    


    
    

    
    

    

    

    
    
    
    
    


    
    

    
    
    

    
    
    
    
    


    
    
    


    
    
    




    
    

    
    
    



    





    




    
    

    


    

    


    
    
    
    
    
    


    
    
    
    
    
    


    
    
    
    
    
    


    
    
    
    
    
    


    
    
    
    


    
    
    
    
    
    


    
    

    
    
    


    
    
    

    
    
    



    






    














    

    
    




    
    




    

    
    





    

    
    
    




    
    
    
    




    

    
    
    
    
    





    

    
    




    
    




    

    
    





    

    
    
    




    
    
    
    




    

    
    
    
    
    






    

    
    
    
    
    

    
    

    
    
    
    
    
    





    

    
    
    

    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    







    

    
    
    
    
    

    
    

    
    
    
    
    
    





    

    
    
    

    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    





































    



    



    




    




    




    





    




    




    
    




    












    
    
    
    
        
        
            
        
    
    

    





    
    
    
        
    
        
    
    

    





    
    
    
        
    
    
        
            
        
    
    
    
        
        
        
            
        
    
    

    





    
    
        
    
    

    











    



    
    
    




    
    



    
    
    



    
    
    





    



    

    

    



    

    

    




    
    
        
        
        
    
    



    



    
    
        
        
        
            
            
            
            
            
        
    
    
    
    
    




    
    
        
        
        
    
    




    
    
    




    
    
        
        
        
            
            
            
            
            
        
    
    
    
    
    
    


































    
        
        
        
    
    

    
    
        
        

        
        

        

        
        
    
    

    





















    
    
    
        
    
    
        
    
    
    
    
        
    



    
    
    
        
    
        
    
    
    
    
    
        
    






    
    
    
        
    
        
    



    
        
    
        
    
        
    










                                      

    
    
    
    



    
    
    
    
        
        
        
            
            
        
        
            
    
    



    
    

        
        
        
        

        

    
    
    


                                
                                
                                


    
    
    
    
    
        
            
        
            
    
    
    
        
    
        
    
        
    
        
    
    
    
    
        
            
        
    
    
    
        
        
    
    
    
    
        
        
        
        
        
        
        
            
        
            
        
        
            
                
            
                
            
            
            
        
        
            
        
            
        
    
        
        
        
        
            
                
            
        
            
                
            
                
            
                
            
        
            
                
            
                
            
        
            
                
            
        
        
            
        
        
            
            
        
        
    
    
    
        
        
    
        
        
        
            
        
        
            
                
            
            
                
                
            
        
        
        
            
            
                
            
            
                
                    
                
                
                    
                    
                
            
        
        
    
    
    
        
        
        
    

    
    
    
    












































    
    
        

    

    
        

    
        


    
    
        

    
    
        
        
            
            
        
        
            
    

    

    

    

    

    

    
        



    



    
        

    

    


    
        

    
        
        
            
            
        
    

    

    

    

    

    

    












    



    
    
    
    
        
        
        
            
        
        
    
    

    
    
    
    
        
        
        
            
        
        
            
        
    
    




    




    



    
    
    
    
        
        
        
        
            
        
    
    

    
    
    
    
        
        
        
            
        
        
            
        
    
    




    











    
    
    
    
    
    
        


        

        

        

        
            
        

            


            

            
            
        
        
    
    
    



    
    
    
    
    
    
        


        

        

        

        
            
        

            


            

            
            
        
        
    
    
    














    
    
    








    
    
    








     
    
        
    
    
    








    
    
        

    

    
    

    
    








    
    

    
    
    
    
    
    

    
    
    
    
    

    








     
    
        
    
    
    








    
    
    
    
    
    
    
    
    








    
    
        
    
    
    








     
    
        
    
    
    








    
    
    
        
    
    
        
    
        
    
    
    








    
    
        

    

    
    

    
    








    
    
    
    
    
        
    
        
    
    
    
    
    








    
    
        
    
    
    








     
    
        
    
    
    








    
    
    
        
    
    
        
    
        
    
    
    




    
    
    
    
    
    
    

    

    
    
    

        
            
            
            
        


        
            
            
            
        

        
    

        
            
            
            
        


        
            
            
            
        


        
            
            
            
        

        
    

        
            
            
            
        


        
            
            
            
        


        
            
            
            
        


        
            
            
            
        


        
            
            
            
        

        
    

        
            
            
        


        
            
            
            
        


        
            
            
            
        

        
    
    
        
    
        
    
    
    
        
    
        
    
    



    
        
    
        
    
        
    
        
    



    
    
    
    

    

    



    
        
            
    
    

    

    
    

    




    
    
        
        
    

    
    

    
    

    




    

        

    
    
    




































         

         



































    

    

    
    
    
    

    
    
        


    
    
        
        
            
            
        
    

    
        
        
    
    



    
    
    

    

    




    


    
        
        
            
    


    
        
        
            
            
                
        
            
            
        
    

    


    

    
    
    


    

    

    

    

    
    
    

    
    
    

    

    
    



    
    
        
        
    

    
        
        
        
    


    
        
        
    


    
        
        
        
    


    
    
    
    

    
    
    

    
    
    
    
    
    
        
    
    

    
    
    

    
    
    

    
    
    

    
    
    

    
    

    



    

        

    
    
    
































    

    




    
        

    

    

    


    

    

    

    


    





    
    
    
    
    
    
    
    

    
    

    
    

    
    
    
    
    
    
        
    
    

    
    
    

    
    
    
    
    
    
    
    

    
    

    
    

    

    

    
    
    
    
    

    
    
    




    
        

    
        
        
        
        
            
                
    

    
        
        
        
        
            
                
    

    
        
        
        
            
            
                
        
    


    

    





    
    

    
    

    

    

    

    

    


    

    





    
    

    

    





    
    
    

        

        

    
    



    
    
    

        

        

    
    













    


    

    

    

    

    

    








    
    
    

    
    
        
        
        
    
    

    




    

    
        
    
        
    
    

    
        
    
        
    
    

    
        
        
        
    
        
        
        
    
    

    

    



    

    
    
    
        
        
        
    

    




    
    
    
    

    






























    
        
        
    







    







    

    
    
    

    






/* vim:set ts=4 et: */












































//Java #  define assert(e) ((void)0)





































/***********************************************************************
//
************************************************************************/
















/* this always fits into 16 bits */
//Java #define LZO_SIZE(bits)      (1u << (bits))



//Java #define LZO_LSIZE(bits)     (1ul << (bits))








   








/***********************************************************************
// compiler and architecture specific stuff
************************************************************************/

/* Some defines that indicate if memory can be accessed at unaligned
 * memory addresses. You should also test that this is actually faster
 * even if it is allowed by your system.
 */






























   











   











   












/* Fast memcpy that copies multiples of 8 byte chunks.
 * len is the number of bytes.
 * note: all parameters must be lvalues, len >= 8
 *       dest and src advance, len is undefined afterwards
 */











/***********************************************************************
// some globals
************************************************************************/

//Java LZO_EXTERN(const lzo_bytep) lzo_copyright(void);


/***********************************************************************
//
************************************************************************/

//Java #include "lzo_ptr.h"


/* Generate compressed data in a deterministic way.
 * This is fully portable, and compression can be faster as well.
 * A reason NOT to be deterministic is when the block size is
 * very small (e.g. 8kB) or the dictionary is big, because
 * then the initialization of the dictionary becomes a relevant
 * magnitude for compression speed.
 */



















//Java #  define lzo_dict_t    lzo_uint
//Java #  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *







/*
vi:ts=4:et
*/



/* Memory required for the wrkmem parameter.
 * When the required size is 0, you can also pass a NULL pointer.
 */








/***********************************************************************
//
************************************************************************/
































/***********************************************************************
//
************************************************************************/



















/*
vi:ts=4:et
*/






/* lzo1x_d.ch -- implementation of the LZO1X decompression algorithm

   This file is part of the LZO real-time data compression library.

   Copyright (C) 2011 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */


// Java addition: {
private static final int init = 0;
private static final int copy_match = 1;
private static final int eof_found = 2;
private static final int first_literal_run = 3;
private static final int match = 4;
private static final int match_done = 5;
private static final int match_next = 6;
private static final int input_overrun = 7;
private static final int output_overrun = 8;
private static final int lookbehind_overrun = 9;
// End Java addition: }


/* lzo1_d.ch -- common decompression stuff

   This file is part of the LZO real-time data compression library.

   Copyright (C) 2011 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */
















/***********************************************************************
// Overrun detection is internally handled by these macros:
//
//   TEST_IP    test input overrun at loop begin
//   NEED_IP    test input overrun at every input byte
//
//   TEST_OP    test output overrun at loop begin
//   NEED_OP    test output overrun at every output byte
//
//   TEST_LB    test match position
//
// The fastest decompressor results when testing for no overruns
// and using LZO_EOF_CODE.
************************************************************************/














































   




































/*
vi:ts=4:et
*/



/***********************************************************************
// decompress a block of data.
************************************************************************/


public static int
decompress  (  byte[] in, int in_base , int  in_len,
                       byte[] out, int out_base, lzo_uintp out_len,
                       Object wrkmem )

{
    //Java register lzo_bytep op;
	int in_ptr = in_base;
    //Java register const lzo_bytep ip;
	int out_ptr = out_base;
     int t = Integer.MIN_VALUE;

    
    

    //Java: lzo_bytep const op_end = out + *out_len;
    //Java: m_pos is always a pointer into op.
      int m_pos = Integer.MIN_VALUE;


     int  ip_end = in_ptr + in_len;

    int  op_end = out_ptr + out_len.value;


    


    ;

	int state = init;;

GOTO_0: {	// Java-goto


    
    
        
        
            
            
        
        
    
    
    
        
        
    


	//Java *out_len = 0;
    out_len.value = 0;

    //Java op = out;
    //Java ip = in;

	//Java if (*ip > 17)
    if (((in[in_ptr]) & 0xff) > 17)
    {
        //Java t = *ip++ - 17;
        t = ((in[in_ptr++]) & 0xff) - 17;
        if (t < 4)
            //Java goto match_next;
			{ state = match_next; break GOTO_0; }
        assert(t > 0):"Assertion failed: " + "t > 0"; if ((int)(op_end - out_ptr) < (int)(t)) { state = output_overrun; break GOTO_0; }; if ((int)(ip_end - in_ptr) < (int)(t+1)) { state = input_overrun; break GOTO_0; };
        //Java do *op++ = *ip++ while (--t > 0);
        // System.arraycopy(in, in_ptr, out, out_ptr, t);
        // in_ptr += t;
        // out_ptr += t;
		do out[out_ptr++] = in[in_ptr++]; while (--t > 0);
		//Java goto first_literal_run;
        { state = first_literal_run; break GOTO_0; }
    }

}	// GOTO_0	// Java-goto

GOTO_LOOP_OUTER:
    while ((in_ptr < ip_end) && true)
    {
	;
GOTO_PRE: for (;;) { switch (state) { case init:

        //Java t = *ip++;
        t = ((in[in_ptr++]) & 0xff);
        if (t >= 16)
            //Java goto match;
			{ state = match; break GOTO_PRE; }
		;
        /* a literal run */
        if (t == 0)
        {
            if ((int)(ip_end - in_ptr) < (int)(1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
            //Java while (*ip == 0)
            while (in[in_ptr] == 0)
            {
                t += 255;
                //Java ip++;
                in_ptr++;
                if ((int)(ip_end - in_ptr) < (int)(1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
            }
            //Java t += 15 + *ip++;
            t += 15 + ((in[in_ptr++]) & 0xff);
        }
        /* copy literals */
        assert(t > 0):"Assertion failed: " + "t > 0"; if ((int)(op_end - out_ptr) < (int)(t+3)) { state = output_overrun; break GOTO_LOOP_OUTER; }; if ((int)(ip_end - in_ptr) < (int)(t+4)) { state = input_overrun; break GOTO_LOOP_OUTER; };

        
        
        
            
            
        
        
        
            
            
        
        
        
            
            
        


        
        

        
        
        
        
            
            
                
                    
                    
                
                
            
            
                
        

        
        



        {
            //Java *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
            //Java do *op++ = *ip++; while (--t > 0);
            t += 3;
            // System.arraycopy(in, in_ptr, out, out_ptr, t);
            // in_ptr += t;
            // out_ptr += t;
			do out[out_ptr++] = in[in_ptr++]; while (--t > 0);
        }



case first_literal_run:


        //Java t = *ip++;
        t = ((in[in_ptr++]) & 0xff);
		;
        if (t >= 16)
			{ state = match; break GOTO_PRE; }


        
        

        

        
        


        
        
        
		
        

        //Java m_pos = op - (1 + M2_MAX_OFFSET);
        m_pos = out_ptr - (1 + 0x0800);
        m_pos -= t >> 2;
        //Java m_pos -= *ip++ << 2;
        m_pos -= ((in[in_ptr++]) & 0xff) << 2;

		;
        if (m_pos < out_base || m_pos >= out_ptr) { state = lookbehind_overrun; break GOTO_LOOP_OUTER; }; if ((int)(op_end - out_ptr) < (int)(3)) { state = output_overrun; break GOTO_LOOP_OUTER; };
        //Java *op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;
        out[out_ptr++] = out[m_pos++];
        out[out_ptr++] = out[m_pos++];
        out[out_ptr++] = out[m_pos];

        //Java goto match_done;
		{ state = match_done; break GOTO_PRE; }

case match:
case match_next:
	break GOTO_PRE;
case input_overrun:
case output_overrun:
case lookbehind_overrun:
	break GOTO_LOOP_OUTER;
default: throw new IllegalStateException("Illegal state " + state); } }

// Enter the inner loop:

GOTO_LOOP_INNER:
        /* handle matches */
        do {
	;
GOTO_INNER: for (;;) { switch (state) { case init:
case match:
            if (t >= 64)                /* a M2 match */
            {


                
                

                
                

                
                
                    
                
                
                    
                    
                
                



                //Java m_pos = op - 1;
                m_pos = out_ptr - 1;
                m_pos -= (t >> 2) & 7;
                //Java m_pos -= *ip++ << 3;
                m_pos -= ((in[in_ptr++]) & 0xff) << 3;
                t = (t >> 5) - 1;

                
                
                
                
                
                

                
                    
                    
					
                    
                    
                        
                        
                    
                    
                    
                        
                        
                        
                        
                    
                
                

				;
                if (m_pos < out_base || m_pos >= out_ptr) { state = lookbehind_overrun; break GOTO_LOOP_OUTER; }; assert(t > 0):"Assertion failed: " + "t > 0"; if ((int)(op_end - out_ptr) < (int)(t+3-1)) { state = output_overrun; break GOTO_LOOP_OUTER; };
                //Java goto copy_match;
                { state = copy_match; continue GOTO_INNER; }

            }
            else if (t >= 32)           /* a M3 match */
            {
                t &= 31;
                if (t == 0)
                {
                    if ((int)(ip_end - in_ptr) < (int)(1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
                    //Java while (*ip == 0)
                    while (in[in_ptr] == 0)
                    {
                        t += 255;
                        //Java ip++;
                        in_ptr++;
                        if ((int)(ip_end - in_ptr) < (int)(1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
                    }
                    //Java t += 31 + *ip++;
                    t += 31 + ((in[in_ptr++]) & 0xff);
                }


                
                

                



                
                    
                    
                    
                    
                    
                

                
                
                

                //Java m_pos = op - 1;
                m_pos = out_ptr - 1;
                //Java m_pos -= (ip[0] >> 2) + (ip[1] << 6);
                m_pos -= (((in[in_ptr]) & 0xff) >> 2) + (((in[in_ptr + 1]) & 0xff) << 6);


                //Java ip += 2;
                in_ptr += 2;
				;
            }
            else if (t >= 16)           /* a M4 match */
            {

                

                //Java m_pos = op;
                m_pos = out_ptr;
                m_pos -= (t & 8) << 11;

                t &= 7;
                if (t == 0)
                {
                    if ((int)(ip_end - in_ptr) < (int)(1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
                    //Java while (*ip == 0)
                    while (in[in_ptr] == 0)
                    {
                        t += 255;
                        //Java ip++;
                        in_ptr++;
                        if ((int)(ip_end - in_ptr) < (int)(1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
                    }
                    //Java t += 7 + *ip++;
                    t += 7 + ((in[in_ptr++]) & 0xff);
                }


                
                

                
                

                
                
                
                    
					
                

                



                
                

                

                //Java m_pos -= (ip[0] >> 2) + (ip[1] << 6);
                m_pos -= (((in[in_ptr]) & 0xff) >> 2) + (((in[in_ptr + 1]) & 0xff) << 6);

                //Java ip += 2;
                in_ptr += 2;
                //Java if (m_pos == op)
                if (m_pos == out_ptr)
                    //Java goto eof_found;
					{ state = eof_found; break GOTO_LOOP_OUTER; }
                m_pos -= 0x4000;

                
                


            }
            else                            /* a M1 match */
            {


                
                

                

                
                


                
                
                
                
                

                //Java m_pos = op - 1;
                m_pos = out_ptr - 1;
                m_pos -= t >> 2;
                //Java m_pos -= *ip++ << 2;
                m_pos -= ((in[in_ptr++]) & 0xff) << 2;

				;
                if (m_pos < out_base || m_pos >= out_ptr) { state = lookbehind_overrun; break GOTO_LOOP_OUTER; }; if ((int)(op_end - out_ptr) < (int)(2)) { state = output_overrun; break GOTO_LOOP_OUTER; };
                //Java *op++ = *m_pos++; *op++ = *m_pos;
                out[out_ptr++] = out[m_pos++];
                out[out_ptr++] = out[m_pos];

                //Java goto match_done;
				{ state = match_done; continue GOTO_INNER; }
            }

            /* copy match */


            
            



			;
            if (m_pos < out_base || m_pos >= out_ptr) { state = lookbehind_overrun; break GOTO_LOOP_OUTER; }; assert(t > 0):"Assertion failed: " + "t > 0"; if ((int)(op_end - out_ptr) < (int)(t+3-1)) { state = output_overrun; break GOTO_LOOP_OUTER; };

            
            
                
                
                
                    
                    
                
                
                
                    
                    
                
                
                
                    
                    
                
            
            


            
            
                

            
            

                
                
                
                    
                    
                
                
            
            

case copy_match:
            {
                //Java *op++ = *m_pos++; *op++ = *m_pos++;
                //Java do *op++ = *m_pos++; while (--t > 0);
                t += 2;
				do out[out_ptr++] = out[m_pos++]; while (--t > 0);
            }



case match_done:

            
            

            //Java t = ip[-2] & 3;
            t = in[in_ptr -2] & 3;

            if (t == 0)
                break GOTO_LOOP_INNER;

            /* copy literals */
case match_next:
            assert(t > 0):"Assertion failed: " + "t > 0"; assert(t < 4):"Assertion failed: " + "t < 4"; if ((int)(op_end - out_ptr) < (int)(t)) { state = output_overrun; break GOTO_LOOP_OUTER; }; if ((int)(ip_end - in_ptr) < (int)(t+1)) { state = input_overrun; break GOTO_LOOP_OUTER; };
//Java #if 0

            //Java do *op++ = *ip++; while (--t > 0);
            do out[out_ptr++] = in[in_ptr++]; while (--t > 0);

            
            

            //Java t = *ip++;
			t = ((in[in_ptr++]) & 0xff);
break; default: throw new IllegalStateException("Illegal state " + state); } break; }
		state = init;
        } while ((in_ptr < ip_end) && true);
// GOTO_LOOP_INNER

		state = init;
    }
// GOTO_LOOP_OUTER

GOTO_3: for (;;) { switch (state) { case init:

    /* no EOF code was found */
    //Java *out_len = pd(op, out);
    out_len.value = out_ptr - out_base;
    return LZO_E_EOF_NOT_FOUND;


case eof_found:
    assert(t == 1):"Assertion failed: " + "t == 1";
    //Java *out_len = pd(op, out);
    out_len.value = out_ptr - out_base;
    //Java return (ip == ip_end ? LZO_E_OK :
    //Java (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
    return (in_ptr == ip_end ? LZO_E_OK :
           (in_ptr < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));



case input_overrun:
    //Java *out_len = pd(op, out);
    out_len.value = out_ptr - out_base;
    return LZO_E_INPUT_OVERRUN;



case output_overrun:
    //Java *out_len = pd(op, out);
    out_len.value = out_ptr - out_base;
    return LZO_E_OUTPUT_OVERRUN;



case lookbehind_overrun:
    //Java *out_len = pd(op, out);
    out_len.value = out_ptr - out_base;
    return LZO_E_LOOKBEHIND_OVERRUN;


default: throw new IllegalStateException("Illegal state " + state); } }
}


/*
vi:ts=4:et
*/


	@Override
	public int decompress(byte[] in, int in_base, int in_len,
                         byte[] out, int out_base, lzo_uintp out_len) {
		return decompress(in, in_base, in_len,
						  out, out_base, out_len, null);
	}
}
